function [] = demo_gui_process(app)
% 初始化参数
long = 32784;     % 单次数据长度（含头）
tcp_num_packets = 10;  % 接收帧数
tcp_trans_length = long;
fs = 30e6;
frame_head = [85 170 85 170 85 170 85 170];
frqPoint = 301:311;
Rs = [1,3,7,15,31]; % 用于调制识别
nnqam = {'QPSK','QAM16','QAM64','QAM256','QAM1024'};
nqam = [4,16,64,256,1024];

RecDataDisp = [];

while true
    switch app.STATE
        case demo_gui_state.IDLE
            % Do nothing

        case demo_gui_state.CONN
            if ~app.TCP_OK
                t = tcpip('192.168.137.10',5001,'NetworkRole','server');
                t.InputBuffersize = long;
                fopen(t);
                flushoutput(t);
                fwrite(t, [0xAA, 0x55, 0xFF, 0xA0], 'uint8'); % 开始命令

                tcp_receive_cnt = 0;
                while tcp_receive_cnt < 20
                    if t.BytesAvailable >= tcp_trans_length
                        Recv = fread(t, t.BytesAvailable);
                        RecDataDisp = [RecDataDisp; Recv];
                        tcp_receive_cnt = tcp_receive_cnt + 1;
                    end
                end

                fwrite(t, [0xAA, 0x55, 0xFF, 0xB1], 'uint8'); % 停止命令
                fclose(t);
                app.TCP_OK = true;
            end

        case demo_gui_state.RUN
            % 同步帧查找
            match_pos = strfind(RecDataDisp(:).', frame_head);
            RecDataFrqPoint = hex2dec(string(dec2hex(uint8(RecDataDisp(match_pos+9)))) + string(dec2hex(uint8(RecDataDisp(match_pos+8)))));
            match_pos_syncStart = strfind(RecDataFrqPoint(:).', frqPoint);
            TrueSyncStart = match_pos(match_pos_syncStart(1):match_pos_syncStart(1)+tcp_num_packets);

            RecDataIQ = zeros(8192, tcp_num_packets+1);
            EnergyRecData = zeros(tcp_num_packets+1,1);
            S21Data = zeros(tcp_num_packets+1,1);
            Spectrum = [];
            f = [];

            for i = 1:tcp_num_packets+1
                RecDataSingle = RecDataDisp(TrueSyncStart(i):TrueSyncStart(i)+tcp_trans_length-1);
                RecDataIQ(:,i) = process_i_16bit(RecDataSingle);

                % 能量估计
                EnergyRecData(i) = mean(abs(RecDataIQ(:,i)));

                % 插值重建 + 频谱分析
                rx_up = upsample(RecDataIQ(:,i), 2);
                h = rcosdesign(0.35, 8, 8);
                rx_interp = conv(rx_up, h, 'same');
                N = length(rx_interp);
                rx_fft = mag2db(abs(fftshift(fft(rx_interp, 2^nextpow2(N)))));
                S21Data(i) = rx_fft(8193);
                rx_fft(8193) = [];
                Spectrum = [Spectrum; rx_fft(8192-2048:8192+2048)];
                f = [f, linspace(-fs/2 + frqPoint(i)*1e7, fs/2 + frqPoint(i)*1e7, length(rx_fft))];
            end

            % 画 S21 图
            Freq = linspace(3e9, 3.1e9, length(S21Data))';
            FreqInterp = linspace(3e9, 3.1e9, 10 * length(S21Data))';
            S21DataInterp = interp1(Freq, S21Data, FreqInterp, 'spline');
            S21DataInterpNoisy = awgn(S21DataInterp, 1);
            app.S21.XLim = [FreqInterp(1) FreqInterp(end)];
            app.S21.YLim = [1 100];
            plot(app.S21, FreqInterp, S21DataInterpNoisy);
            

            % 画频谱图
            Freq = linspace(3e9, 3.1e9, length(Spectrum))';
            app.Spectrum.XLim = [Freq(1), Freq(end)];
            plot(app.Spectrum, Freq, Spectrum);
            

            % 星座图 & IQ提取
            [~, idxEnergy] = max(EnergyRecData);
            IQ = RecDataIQ(:, idxEnergy);
            threshold = max(abs(IQ))*0.08;
            idxIQ = find(abs(IQ)>threshold);
            idxIQ = idxIQ(5:end);
            IQ = IQ(idxIQ);

            plot(app.IRecWfm, real(IQ), 'r');
            plot(app.QRecWfm, imag(IQ), 'b');
            plot(app.CstDiag, IQ, '.');

            % QAM调制类型估计
            radii = abs(IQ);
            r_max = mean(maxk(radii, 50));
            r_min = mean(mink(radii, 50));
            R = r_max / r_min;
            [~, idx] = min(abs(Rs - R));
            QAM_type = nnqam{idx};
            app.ModulationTypeTextArea.Value = QAM_type;

            % EVM估计
            Bits = randi([0 nqam(idx)-1], length(IQ), 1);
            ref_data = qammod(Bits, nqam(idx), 'UnitAveragePower', true);
            IQ_norm = IQ / rms(IQ);
            ideal_IQ = zeros(size(IQ));
            for k = 1:length(IQ)
                [~, closest] = min(abs(IQ_norm(k) - ref_data));
                ideal_IQ(k) = ref_data(closest);
            end
            evm_vector = IQ_norm - ideal_IQ;
            EVM_rms = sqrt(mean(abs(evm_vector).^2));
            EVM_ref = sqrt(mean(abs(ideal_IQ).^2));
            EVM_percent = (EVM_rms / EVM_ref) * 100;
            app.EVMTextArea.Value = num2str(EVM_percent);
            fprintf('EVM = %.2f %%\n', EVM_percent);

            % IQ增益不平衡
            gain_I = rms(real(IQ));
            gain_Q = rms(imag(IQ));
            gain_imbalance = 20 * log10(gain_I / gain_Q);
            fprintf('Gain Imbalance = %.2f dB\n', gain_imbalance);
            app.GainIQImbalanceTextArea.Value = num2str(gain_imbalance);

            % IQ相位不平衡
            I_dc = real(IQ) - mean(real(IQ));
            Q_dc = imag(IQ) - mean(imag(IQ));
            phi_rad = acos(dot(I_dc, Q_dc) / (norm(I_dc) * norm(Q_dc)));
            phi_deg = rad2deg(phi_rad) - 90;
            fprintf('Phase Imbalance = %.2f degrees\n', phi_deg);
            app.PhaseIQImbalanceTextArea.Value = num2str(phi_deg);
                
    end

    pause(0.5); % 控制更新节奏
end
end
